---
title: '[Python] list|dict|set实现原理'
date: 2020-10-13 17:27:46
tags: #Python
---

本文主要讲解Python中list,dict,set的实现原理。
<!-- more -->

## list

本质是顺序表(长度可变的数组，连续的内存空间)，能够动态扩容。

PS: tuple与list的主要区别就是tuple是不可变的，一旦创建不可修改，而list是可变的，且可以扩容。

1. 元素有位置下标，通过索引可以直接取得元素。--> list创建时会划分出一块连续的固定大小的内存空间，根据偏移量计算元素的位置，不需要遍历所有的元素。
2. 元素无论如何改变，表对象不变，即其id不变。--> 分离式结构，即表头和元素分开存储，这样在更改list时，表对象始终是同一个，只是指向的地址不同。
3. 元素可以是任意类型。 --> 即要求是连续的内存空间，同时又要求存储不同类型的数据，所以list存储的只是内存地址的引用，元素外置的方式进行元素的存储。
4. 可以添加任意数量的新元素。 --> 动态扩容。

| 操作                     | 复杂度 |
| ------------------------ | ------ |
| 复制                     | O(N)   |
| 添加元素(在尾部添加)     | O(1)   |
| 插入元素(在指定位置插入) | O(N)   |
| 获取元素                 | O(1)   |
| 修改元素                 | O(1)   |
| 删除元素                 | O(N)   |
| 遍历                     | O(N)   |
| 获取长度为k的切片        | O(k)   |
| 删除切片                 | O(N)   |
| 列表扩展                 | O(k)   |
| 测试是否在列表中         | O(N)   |
| min()/max()              | O(n)   |
| 获取列表长度             | O(1)   |

## dict

本质是哈希表，对于每一个key值计算其对应的hash值，用作value的索引。

1. 不考虑哈希冲突的情况下，key与value一一对应，查询修改删除元素的时间复杂度为O(1)。
2. 根据哈希表的实现原理，key值必须选取可哈希的对象，即python中的不可变对象。而list,dict,set这些可变对象则不能作为key值。

| 操作     | 平均复杂度 | 平摊最坏情况复杂度 |
| -------- | ---------- | ------------------ |
| 获取元素 | O(1)       | O(n)               |
| 修改元素 | O(1)       | O(n)               |
| 删除元素 | O(1)       | O(n)               |
| 复制     | O(n)       | O(n)               |
| 遍历     | O(n)       | O(n)               |

## set

本质与dict类同，都是哈希表，但是对其做了去重操作。平均时间复杂度为O(1)，最坏为O(n)。

去重操作的原理：

1. 首先调用"\__hash__"方法计算两个key值得hash结果是否相同。
2. 如果hash结果相同，可能是重复元素，也可能是哈希冲突，其实value不同。
3. 此时调用""\__eq__"方法查看两者的value是否相等，如果不等，则为哈希冲突，不去重，如果相等，则去重。

```python
"""
set去重原理
"""
class Foo:
    def __init__(self, name, count):
        self.name = name
        self.count = count

    def __hash__(self):
        print("%s调用了hash方法" % self.name)
        return hash(self.count)

    def __eq__(self, other):
        print("%s调用了eq方法" % self.name)
        return self.__dict__ == other.__dict__


f1 = Foo("f1", 1)
f2 = Foo("f2", 1)
print(f1, f2)
ls = [f1, f2]
print(set(ls))


"""
# 首先调用__hash__方法计算hash值，发现两者count的hash值相等
# 所以调用__eq__方法，查看两者的类属性，变量等是否完全相同，最后发现两者的name属性不同，所以不是重复元素
f1 调用了__hash__
f2 调用了__hash__
f1 调用了__eq__
{<__main__.Foo object at 0x12005eef0>, <__main__.Foo object at 0x12006f160>}
"""
```
