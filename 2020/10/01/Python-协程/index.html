<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"localhost","root":"/","scheme":"Muse","version":"8.0.0-rc.4","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}}};
  </script>

  <meta name="description" content="本文将探讨yield from实现协程的相关概念与原理，async&#x2F;await使用方法，以及进一步展示如何用asyncio实现异步HTTP请求。">
<meta property="og:type" content="article">
<meta property="og:title" content="[Python]协程">
<meta property="og:url" content="http://localhost:4000/2020/10/01/Python-%E5%8D%8F%E7%A8%8B/index.html">
<meta property="og:site_name" content="SinGle&#39;s Cabin">
<meta property="og:description" content="本文将探讨yield from实现协程的相关概念与原理，async&#x2F;await使用方法，以及进一步展示如何用asyncio实现异步HTTP请求。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://localhost:4000/2020/10/01/Python-%E5%8D%8F%E7%A8%8B/%E5%8D%8F%E7%A8%8B%E5%8E%9F%E7%90%86.png">
<meta property="article:published_time" content="2020-10-01T04:42:01.000Z">
<meta property="article:modified_time" content="2020-10-01T04:48:28.182Z">
<meta property="article:author" content="SinGle">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://localhost:4000/2020/10/01/Python-%E5%8D%8F%E7%A8%8B/%E5%8D%8F%E7%A8%8B%E5%8E%9F%E7%90%86.png">

<link rel="canonical" href="http://localhost:4000/2020/10/01/Python-%E5%8D%8F%E7%A8%8B/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>[Python]协程 | SinGle's Cabin</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">SinGle's Cabin</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#关于协程"><span class="nav-number">1.</span> <span class="nav-text">关于协程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#yield-from"><span class="nav-number">2.</span> <span class="nav-text">yield from</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#yield-from-简单功能"><span class="nav-number">2.1.</span> <span class="nav-text">yield from 简单功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#send-close-throw-协程实现基础"><span class="nav-number">2.2.</span> <span class="nav-text">send, close, throw 协程实现基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生成器状态解释"><span class="nav-number">2.3.</span> <span class="nav-text">生成器状态解释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用yield-from实现协程"><span class="nav-number">2.4.</span> <span class="nav-text">使用yield from实现协程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#yield-from-小结"><span class="nav-number">2.5.</span> <span class="nav-text">yield from 小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#async-与-await"><span class="nav-number">3.</span> <span class="nav-text">async 与 await</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#asyncio实现HTTP请求"><span class="nav-number">4.</span> <span class="nav-text">asyncio实现HTTP请求</span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">SinGle</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content post posts-expand">
          

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://localhost:4000/2020/10/01/Python-%E5%8D%8F%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SinGle">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SinGle's Cabin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          [Python]协程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-10-01 12:42:01 / Modified: 12:48:28" itemprop="dateCreated datePublished" datetime="2020-10-01T12:42:01+08:00">2020-10-01</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>本文将探讨yield from实现协程的相关概念与原理，async/await使用方法，以及进一步展示如何用asyncio实现异步HTTP请求。</p>
<a id="more"></a>

<h2 id="关于协程"><a href="#关于协程" class="headerlink" title="关于协程"></a>关于协程</h2><p>使用协程的原因：</p>
<ol>
<li>使用select注册+事件循环+回调的模式，代码复杂度高，维护困难。</li>
<li>多线程实现并发，线程间切换成本高，线程间同步需要lock，效率低下。</li>
<li>同步编程是阻塞IO，效率低下</li>
</ol>
<p>对于协程的要求：</p>
<ol>
<li>希望能够使用同步的方式来编写异步的代码。</li>
<li>能够使用单线程进行任务的切换。</li>
</ol>
<p>两个要点：</p>
<ol>
<li>线程与进程是由操作系统进行切换的，而单线程内的切换意味着需要程序员自己进行操作。</li>
<li>需要一个可以暂停的函数，并且可以在适当的时候恢复其运行。</li>
</ol>
<p>所以有了协程，两种描述：</p>
<ul>
<li>拥有多个入口的函数(更精确的形容)</li>
<li>可以暂停的函数(更易于理解的形容)，可以向暂停的地方传入值</li>
</ul>
<h2 id="yield-from"><a href="#yield-from" class="headerlink" title="yield from"></a>yield from</h2><h3 id="yield-from-简单功能"><a href="#yield-from-简单功能" class="headerlink" title="yield from 简单功能"></a>yield from 简单功能</h3><p>首先，yield from本身拥有一个简单的功能，即yield from iterable。只要实现了<strong>iter</strong>魔法函数的对象都可以使用yield from EXPR进行操作。与yield相比，yield from会将接收到的iterable对象再次展开，相当于for item in EXPR: yield item。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">r = range(<span class="number">5</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen1</span><span class="params">(item)</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> item</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen2</span><span class="params">(item)</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> item</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> gen1(r):</span><br><span class="line">    print(item)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> gen2(r):</span><br><span class="line">    print(item)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">range(0, 5)</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">4</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<h3 id="send-close-throw-协程实现基础"><a href="#send-close-throw-协程实现基础" class="headerlink" title="send, close, throw 协程实现基础"></a>send, close, throw 协程实现基础</h3><p>生成器能够产出值和接收值。</p>
<p>send方法是核心，能够允许调用方在外部向生成器内部传入值，生成器会暂停在yield处，此时在外部通过send方法传入值，会重新激活该生成器向下运行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span></span><br><span class="line">    x = <span class="keyword">yield</span></span><br><span class="line">    print(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    gen = gen()</span><br><span class="line">    gen.send(<span class="literal">None</span>)</span><br><span class="line">    gen.send(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File "/Users/single/workspaces/Temp/test.py", line 9, in &lt;module&gt;</span></span><br><span class="line"><span class="string">    gen.send(1)</span></span><br><span class="line"><span class="string">StopIteration</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>



<p>throw方法能够在生成器当前停留的地方抛出异常。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    gen = gen()</span><br><span class="line">    print(next(gen))</span><br><span class="line">    print(next(gen))</span><br><span class="line">    gen.throw(IndexError)</span><br><span class="line">    print(next(gen))</span><br><span class="line">    print(next(gen))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">在生成器当前停止的地方抛出异常</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File "/Users/single/workspaces/Temp/test.py", line 12, in &lt;module&gt;</span></span><br><span class="line"><span class="string">    gen.throw(IndexError)</span></span><br><span class="line"><span class="string">  File "/Users/single/workspaces/Temp/test.py", line 3, in gen</span></span><br><span class="line"><span class="string">    yield 2</span></span><br><span class="line"><span class="string">IndexError</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>close方法使生成器停止在当前的yield处，再次对其进行next操作会抛出StopIteration异常。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    gen = gen()</span><br><span class="line">    print(next(gen))</span><br><span class="line">    gen.close()</span><br><span class="line">    print(next(gen))</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">  File "/Users/single/workspaces/Temp/test.py", line 10, in &lt;module&gt;</span></span><br><span class="line"><span class="string">    print(next(gen))</span></span><br><span class="line"><span class="string">StopIteration</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>以上三者，实现了让生成器在需要的时候抛出异常或者停止，或者在适当的时候传入值重新将其唤醒，基本满足了协程的需要。</p>
<h3 id="生成器状态解释"><a href="#生成器状态解释" class="headerlink" title="生成器状态解释"></a>生成器状态解释</h3><p>协程可以身处四个状态中的一个。当前状态可以使用inspect.getgeneratorstate(…) 函数确定，该函数会返回下述字符串中的一个。</p>
<p>GEN_CREATED：等待开始执行；</p>
<p>GEN_RUNNING：解释器正在执行（只有在多线程应用中才能看到这个状态）</p>
<p>GEN_SUSPENDED：在 yield 表达式处暂停；</p>
<p>GEN_CLOSED：执行结束；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> inspect <span class="keyword">import</span> getgeneratorstate</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    gen = gen()</span><br><span class="line">    print(getgeneratorstate(gen))</span><br><span class="line">    next(gen)</span><br><span class="line">    print(getgeneratorstate(gen))</span><br><span class="line">    next(gen)</span><br><span class="line">    print(getgeneratorstate(gen))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        next(gen)</span><br><span class="line">    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">        print(getgeneratorstate(gen))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">GEN_CREATED</span></span><br><span class="line"><span class="string">GEN_SUSPENDED</span></span><br><span class="line"><span class="string">GEN_SUSPENDED</span></span><br><span class="line"><span class="string">GEN_CLOSED</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>有了状态，结合能够调整状态的send,close等方法，就有了实现协程的基础。</p>
<h3 id="使用yield-from实现协程"><a href="#使用yield-from实现协程" class="headerlink" title="使用yield from实现协程"></a>使用yield from实现协程</h3><p>首先需要明确三个核心概念：</p>
<ul>
<li>调用方</li>
<li>委托生成器</li>
<li>子生成器</li>
</ul>
<p><img src="/2020/10/01/Python-%E5%8D%8F%E7%A8%8B/%E5%8D%8F%E7%A8%8B%E5%8E%9F%E7%90%86.png" alt="yield from 协程原理"></p>
<p>核心逻辑：调用方通过委托生成器，与子生成器之间构建了一个双向通道。一般情况下，我们编程的调用顺序是层层递进，即main-&gt;grouper-&gt;averager，然后结果返回也是averager-&gt;grouper-&gt;main。而通过yield from，main直接和averager子生成器构建了一个双向通道，averager的结果直接返回给main，main发送的消息也直接传递给averager。</p>
<p>以下是通过yield from实现了协程，对一组数字进行累加操作并获取返回值。</p>
<p>需要注意的关键点：</p>
<ul>
<li><p>在send发送值给协程之前，需要进行预激操作，可以通过next(gen)或gen.send(None)对新创建的协程进行激活，使其执行到第一个yield表达式，准备好作为活跃的协程使用。</p>
</li>
<li><p>协程在yield关键字所在的位置暂停执行。在赋值语句中，如 x = yield y，=右边的代码在赋值之前执行，因此，等到客户端代码再次激活协程时才会赋值给x变量。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">accumulator</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 子生成器 用于异步累加操作</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 从外部传入需要累加的值</span></span><br><span class="line">        x = <span class="keyword">yield</span></span><br><span class="line">        print(<span class="string">"+ &#123;&#125;"</span>.format(x))</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> x:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        total += x</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grouper</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 委托生成器 作为管道使用</span></span><br><span class="line">    total = <span class="keyword">yield</span> <span class="keyword">from</span> accumulator()</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 调用方 与子生成器通过管道实现双向通道</span></span><br><span class="line">    gen = grouper()</span><br><span class="line">    <span class="comment"># 预激协程</span></span><br><span class="line">    gen.send(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">1000000</span>):</span><br><span class="line">        <span class="comment"># main调用方直接向子协程发送累加值</span></span><br><span class="line">        gen.send(i)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      	<span class="comment"># 在计算结束时，再次发送None中断子协程的while True循环</span></span><br><span class="line">        <span class="comment"># 此时子协程终止会抛出StopIteration异常，并把最终结果附加到异常的value属性中</span></span><br><span class="line">        gen.send(<span class="literal">None</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">"total: &#123;&#125;"</span>.format(e.value))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h3 id="yield-from-小结"><a href="#yield-from-小结" class="headerlink" title="yield from 小结"></a>yield from 小结</h3><ol>
<li>子生成器生产的值，都是直接传给调用方的；调用方通过.send()发送的值都是直接传给子生成器的；如果发送的是None，会调用子生成器的<strong>next</strong>()方法，如果不是None，会调用子生成器的.send()方法。</li>
<li>子生成器退出时，最后的return EXPR，会触发一个StopIteration(EXPR)异常</li>
<li>yield from表达式的值，是子生成器终止时，传递给StopIteration异常的第一个参数</li>
<li>如果调用的时候出现StopIteration异常，委托生成器会恢复运行，同时其他的异常会向上抛。</li>
<li>传入委托生成器的异常里，除了GeneratorExit之外，其他所有的异常全部传递给子生成器的throw()方法；如果调用.throw()的时候出现了StopIteration异常，那么就回复委托生成器的运行，其他的异常全部向上抛。</li>
<li>如果在委托生成器上调用.close()或传入GeneratorExit异常，会调用子生成器的.close()方法，没有的话就不调用。如果在.close()的时候出现了异常，那么就向上抛出异常，否则的话委托生成器会抛出GeneratorExit异常。</li>
</ol>
<h2 id="async-与-await"><a href="#async-与-await" class="headerlink" title="async 与 await"></a>async 与 await</h2><ul>
<li>python3.3后引入了原生的python协程，用async和await来完成之前yield from实现的功能，语义更清晰。</li>
<li>凡是用作协程的函数都用async关键字声明，需要将控制权交给调用方的位置，使用await操作，注意这里用的asyncio.sleep方法进行切换，而不是time.sleep，因为await关键字后只能跟实现了<strong>await</strong>魔法函数的对象，切记在协程中不要使用同步阻塞的方法。</li>
<li>asyncio.ensure_future方法可以获取到协程立即返回的future对象。与线程的future对象类似。</li>
<li>asyncio.get_event_loop方法获取到事件循环。</li>
<li>asyncio.run_until_complete方法将会启动事件循环，直到所有future对象都执行完成，返回其结果或者抛出其异常。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">downloader</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">"requesting url: &#123;&#125;"</span>.format(url))</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"finished downloading url."</span>)</span><br><span class="line">    <span class="keyword">return</span> url</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(url)</span>:</span></span><br><span class="line">    result = <span class="keyword">await</span> downloader(url)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    tasks = []</span><br><span class="line">    url = <span class="string">"http://www.books.com/&#123;&#125;"</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        url = url.format(i)</span><br><span class="line">        <span class="comment"># 获取每个异步任务返回的future对象</span></span><br><span class="line">        task = asyncio.ensure_future(get_html(url))</span><br><span class="line">        tasks.append(task)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> asyncio.as_completed(tasks):</span><br><span class="line">        <span class="comment"># 在downloader子协程完成后 才会将返回结果赋值给get_html的result并最终由main函数获取到</span></span><br><span class="line">        result = <span class="keyword">await</span> task</span><br><span class="line">        print(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    start = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取事件循环</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_until_complete(main())</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"last time: &#123;&#125;"</span>.format(time.time() - start))</span><br></pre></td></tr></table></figure>

<h2 id="asyncio实现HTTP请求"><a href="#asyncio实现HTTP请求" class="headerlink" title="asyncio实现HTTP请求"></a>asyncio实现HTTP请求</h2><ol>
<li><strong>asyncio</strong>的<strong>open_connection</strong>方法已经将<strong>socket</strong>部分封装，包括建立socket，连接<strong>host</strong>的动作。该方法返回<strong>StreamWriter</strong>和<strong>StreamReader</strong>对象用于数据的读写。</li>
<li><strong>StreamWriter.write</strong>已经完成了<strong>unregister</strong>将文件标识符取消注册以及<strong>register</strong>重新注册<strong>EVENT_READ</strong>可读事件的动作，所以直接进行写操作即可。</li>
<li><strong>async for</strong> 语法，通过深度展开<strong>StreamReader</strong> -&gt; <strong>anext</strong>魔法函数-&gt; <strong>readline</strong> -&gt; <strong>readuntil</strong> -&gt; <strong>wait_for_data</strong> -&gt; <strong>resume_reading</strong> -&gt; <strong>loop._add_reader</strong> -&gt;  <strong>register</strong>注册可读事件 -&gt; 调用<strong>call_back</strong>回调函数 -&gt; 最终调用<strong>sock.recv</strong>函数。也就是将我们手动实现的<strong>socket.recv</strong>高度封装。</li>
<li><strong>asyncio.ensure_future</strong>方法，与多线程类似，协程是调用后立即返回<strong>future</strong>对象，不阻塞，通过该方法获取到每个协程任务对应的<strong>future</strong>返回。</li>
<li>通过<strong>asyncio.as_completed</strong>方法，获取执行完成的任务返回结果。</li>
<li>在主函数中，依然需要通过<strong>asyncio.get_event_loop</strong>创建一个<strong>loop</strong>，采用事件循环的方式对协程进行统一调度，以上的方法都在内部检查了<strong>loop</strong>是否存在且被传入，如果不存在<strong>loop</strong>，内部封装的逻辑会自行创建一个<strong>loop</strong>并加入到类属性当中。</li>
<li>最后使用<strong>asyncio.run_until_complete</strong>方法启动主逻辑即可。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用asyncio实现协程</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_html</span><span class="params">(url)</span>:</span></span><br><span class="line">        url = urlparse(url)</span><br><span class="line">        host = url.netloc</span><br><span class="line">        path = url.path</span><br><span class="line">        <span class="keyword">if</span> path == <span class="string">""</span>:</span><br><span class="line">            path = <span class="string">"/"</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 创建连接并返回异步读写对象</span></span><br><span class="line">        reader, writer = <span class="keyword">await</span> asyncio.open_connection(host, <span class="number">80</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 发送数据</span></span><br><span class="line">        writer.write(<span class="string">"GET &#123;&#125; HTTP/1.1\r\nHOST: &#123;&#125;\r\nConnection: close\r\n\r\n"</span>.format(path, host).encode())</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 接收数据</span></span><br><span class="line">        all_lines = []</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">for</span> raw_line <span class="keyword">in</span> reader:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> raw_line:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            all_lines.append(raw_line.decode())</span><br><span class="line">        data = <span class="string">"\n"</span>.join(all_lines)</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 获取所有需要访问的url</span></span><br><span class="line">    urls = [<span class="string">"http://shop.projectsedu.com/goods/&#123;&#125;/"</span>.format(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">    tasks = []</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        <span class="comment"># 创建任务并获取每个任务异步返回的future对象</span></span><br><span class="line">        task = asyncio.ensure_future(get_html(url))</span><br><span class="line">        tasks.append(task)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 通过as_completed方法获取已经完成的异步任务的结果</span></span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> asyncio.as_completed(tasks):</span><br><span class="line">        result = <span class="keyword">await</span> task</span><br><span class="line">        print(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    start = time.time()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建事件循环</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    loop.run_until_complete(main())</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"last_time: &#123;&#125;"</span>.format(time.time() - start))</span><br></pre></td></tr></table></figure>



    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Python/" rel="tag"># Python</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/10/05/Python-%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84Array/" rel="prev" title="[数据结构]动态数组Array">
      <i class="fa fa-chevron-left"></i> [数据结构]动态数组Array
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/08/09/Python-Lock%E4%B8%8ERLock/" rel="next" title="[Python]Lock与RLock">
      [Python]Lock与RLock <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SinGle</span>
</div>
  <div class="powered-by">Powered by <a href="https://single-cabin.com/" class="theme-link" rel="noopener" target="_blank">SinGle-Cabin</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  















  

  

</body>
</html>
