<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"localhost","root":"/","scheme":"Muse","version":"8.0.0-rc.4","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}}};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="Spark Core [源码解析] MemoryPool">
<meta property="og:url" content="http://localhost:4000/2020/05/16/Spark-Core-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-MemoryPool/index.html">
<meta property="og:site_name" content="SinGle&#39;s Cabin">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://localhost:4000/2020/05/16/Spark-Core-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-MemoryPool/MemoryPool.png">
<meta property="og:image" content="http://localhost:4000/2020/05/16/Spark-Core-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-MemoryPool/MemoryPool%E5%AE%8F%E8%A7%82%E5%85%B3%E7%B3%BB.png">
<meta property="article:published_time" content="2020-05-16T06:24:09.000Z">
<meta property="article:modified_time" content="2020-08-09T03:49:11.203Z">
<meta property="article:author" content="SinGle">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://localhost:4000/2020/05/16/Spark-Core-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-MemoryPool/MemoryPool.png">

<link rel="canonical" href="http://localhost:4000/2020/05/16/Spark-Core-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-MemoryPool/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Spark Core [源码解析] MemoryPool | SinGle's Cabin</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">SinGle's Cabin</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>







</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#MemoryMode"><span class="nav-number">1.</span> <span class="nav-text">MemoryMode</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MemoryPool抽象类"><span class="nav-number">2.</span> <span class="nav-text">MemoryPool抽象类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#宏观关系"><span class="nav-number">3.</span> <span class="nav-text">宏观关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#StorageMemoryPool"><span class="nav-number">4.</span> <span class="nav-text">StorageMemoryPool</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#acquireMemory"><span class="nav-number">4.1.</span> <span class="nav-text">acquireMemory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#releaseMemory"><span class="nav-number">4.2.</span> <span class="nav-text">releaseMemory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#freeSpaceToShrinkPool"><span class="nav-number">4.3.</span> <span class="nav-text">freeSpaceToShrinkPool</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ExecutionMemoryPool"><span class="nav-number">5.</span> <span class="nav-text">ExecutionMemoryPool</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#acquireMemory-1"><span class="nav-number">5.1.</span> <span class="nav-text">acquireMemory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#releaseMemory-1"><span class="nav-number">5.2.</span> <span class="nav-text">releaseMemory</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#releaseAllMemoryForTask"><span class="nav-number">5.3.</span> <span class="nav-text">releaseAllMemoryForTask</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重点小结"><span class="nav-number">6.</span> <span class="nav-text">重点小结</span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">SinGle</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content post posts-expand">
          

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://localhost:4000/2020/05/16/Spark-Core-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-MemoryPool/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SinGle">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SinGle's Cabin">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spark Core [源码解析] MemoryPool
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-16 14:24:09" itemprop="dateCreated datePublished" datetime="2020-05-16T14:24:09+08:00">2020-05-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-09 11:49:11" itemprop="dateModified" datetime="2020-08-09T11:49:11+08:00">2020-08-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><img src="/2020/05/16/Spark-Core-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-MemoryPool/MemoryPool.png" alt="MemoryPool"></p>
<a id="more"></a>

<h2 id="MemoryMode"><a href="#MemoryMode" class="headerlink" title="MemoryMode"></a>MemoryMode</h2><ul>
<li>内存池实际上是对物理内存的逻辑规划</li>
<li><strong>Spark</strong>用内存模式(<strong>MemoryMode</strong>)从逻辑上区分为堆内内存与堆外内存</li>
<li><strong>MemoryMode</strong>为枚举类型，定义了堆内内存<strong>ON_HEAP</strong>与堆外内存<strong>OFF_HEAP</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Private</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> MemoryMode &#123;</span><br><span class="line">  ON_HEAP,</span><br><span class="line">  OFF_HEAP</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="MemoryPool抽象类"><a href="#MemoryPool抽象类" class="headerlink" title="MemoryPool抽象类"></a>MemoryPool抽象类</h2><p>内存池抽象类的基本方法与属性如下:</p>
<table>
<thead>
<tr>
<th>属性/方法</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><strong>lock</strong></td>
<td>接收lock作为参数，保证操作内存池的线程安全。</td>
</tr>
<tr>
<td><strong>_poolSize</strong></td>
<td>内存池的大小(bytes)。</td>
</tr>
<tr>
<td><strong>poolSize</strong></td>
<td>返回_poolSize内存池大小的方法。</td>
</tr>
<tr>
<td><strong>memoryUsed</strong></td>
<td>获取已经使用的内存大小(bytes)，此方法需要子类实现。</td>
</tr>
<tr>
<td><strong>memoryFree</strong></td>
<td>获取内存池中可用的内存大小(bytes)，即_poolSize与memoryUsed的差值。</td>
</tr>
<tr>
<td><strong>incrementPoolSize</strong></td>
<td>给内存池扩容，扩容大小为delta，delta必须为正。</td>
</tr>
<tr>
<td><strong>decrementPoolSize</strong></td>
<td>给内存池缩容，缩容大小为delta，delta必须为正，delta必须小于内存池总大小，缩小后剩余的内存池大小必须大于已经被使用的内存(即已经使用的内存不可以从内存池中移除)。</td>
</tr>
</tbody></table>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[memory] <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryPool</span>(<span class="params">lock: <span class="type">Object</span></span>) </span>&#123;</span><br><span class="line">  <span class="meta">@GuardedBy</span>(<span class="string">"lock"</span>)</span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">var</span> _poolSize: <span class="type">Long</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">poolSize</span></span>: <span class="type">Long</span> = lock.synchronized &#123;</span><br><span class="line">    _poolSize</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">memoryFree</span></span>: <span class="type">Long</span> = lock.synchronized &#123;</span><br><span class="line">    _poolSize - memoryUsed</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">incrementPoolSize</span></span>(delta: <span class="type">Long</span>): <span class="type">Unit</span> = lock.synchronized &#123;</span><br><span class="line">    require(delta &gt;= <span class="number">0</span>)</span><br><span class="line">    _poolSize += delta</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">decrementPoolSize</span></span>(delta: <span class="type">Long</span>): <span class="type">Unit</span> = lock.synchronized &#123;</span><br><span class="line">    require(delta &gt;= <span class="number">0</span>)</span><br><span class="line">    require(delta &lt;= _poolSize)</span><br><span class="line">    require(_poolSize - delta &gt;= memoryUsed)</span><br><span class="line">    _poolSize -= delta</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">memoryUsed</span></span>: <span class="type">Long</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="宏观关系"><a href="#宏观关系" class="headerlink" title="宏观关系"></a>宏观关系</h2><p><strong>MemoryPool</strong>抽象类有两种具体实现:</p>
<ul>
<li><strong>StorageMemoryPool</strong> 存储体系用到的内存池</li>
<li><strong>ExecutionMemoryPool</strong> 计算引擎用到的内存池</li>
</ul>
<p>他们都受到<strong>MemoryManager</strong>的统一管理，而<strong>MemoryManager</strong>也有两种具体实现:</p>
<ul>
<li><strong>StaticMemoryManager</strong> 静态内存管理(存储与计算内存池大小固定)</li>
<li><strong>UnifiedMemoryManager</strong> 统一内存管理(存储与计算内存池互相借用，动态分配)</li>
</ul>
<p><img src="/2020/05/16/Spark-Core-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-MemoryPool/MemoryPool%E5%AE%8F%E8%A7%82%E5%85%B3%E7%B3%BB.png" alt="MemoryPool宏观关系"></p>
<h2 id="StorageMemoryPool"><a href="#StorageMemoryPool" class="headerlink" title="StorageMemoryPool"></a>StorageMemoryPool</h2><table>
<thead>
<tr>
<th>属性/方法</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><strong>lock</strong></td>
<td>继承了MemoryPool的lock属性，保证操作内存的线程安全。</td>
</tr>
<tr>
<td>_<strong>poolSize</strong></td>
<td>继承了MemoryPool的属性，StorageMemoryPool内存池的大小。</td>
</tr>
<tr>
<td><strong>MemoryMode</strong></td>
<td>内存模式，在逻辑上区分用于存储的内存是堆外内存offHeap还是堆内内存onHeap。offHeap内存为sun.misc.Unsafe的API分配的系统内存，onHeap内存为系统分配给JVM内存的一部分。</td>
</tr>
<tr>
<td><strong>poolName</strong></td>
<td>内存池名称，如果MemoryMode.ON_HEAP则名称为on-heap storage,如果是MemoryMode.OFF_HEAP,则名称为off-heap storage。</td>
</tr>
<tr>
<td>_<strong>memoryUsed</strong></td>
<td>已经使用的内存大小(bytes)</td>
</tr>
<tr>
<td><strong>memoryUsed</strong></td>
<td>实现MemoryPool的方法，返回_memoryUsed的值。</td>
</tr>
<tr>
<td>_<strong>memoryStore</strong></td>
<td>StorageMemoryPool所关联的MemoryStore。</td>
</tr>
<tr>
<td><strong>memoryStore</strong></td>
<td>返回_memoryStore属性引用的MemoryStore。</td>
</tr>
<tr>
<td><strong>setMemoryStore</strong></td>
<td>设置当前StorageMemoryPool所关联的MemoryStore，实际设置了_memoryStore属性。</td>
</tr>
<tr>
<td><strong>releaseAllMemory</strong></td>
<td>释放当前内存池的所有内存，即将_memoryUsed设置为0。</td>
</tr>
</tbody></table>
<p><strong>以下为重点方法详解</strong></p>
<h3 id="acquireMemory"><a href="#acquireMemory" class="headerlink" title="acquireMemory"></a>acquireMemory</h3><p>此方法用于给<strong>blockId</strong>对应的<strong>block</strong>，获取<strong>numBytes</strong>指定大小的内存。</p>
<ul>
<li>首先计算<strong>numBytes</strong>与<strong>memoryFree</strong>的差值，如果<strong>numBytesToFree</strong>&gt;0，说明空闲的内存空间不足，需要驱逐部分<strong>block</strong>占用的内存空间，然后调用重载的<strong>acquireMemory</strong>方法申请内存。</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">acquireMemory</span></span>(blockId: <span class="type">BlockId</span>, numBytes: <span class="type">Long</span>): <span class="type">Boolean</span> = lock.synchronized &#123;</span><br><span class="line">  <span class="keyword">val</span> numBytesToFree = math.max(<span class="number">0</span>, numBytes - memoryFree)</span><br><span class="line">  acquireMemory(blockId, numBytes, numBytesToFree)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>重载的<strong>acquireMemory</strong>方法，用于为<strong>blockId</strong>对应的<strong>block</strong>获取该<strong>block</strong>所需(<strong>numBytesToAcquire</strong>)大小的内存。</li>
<li>当<strong>StorageMemoryPool</strong>内存不足的时候，需要腾出其他<strong>block</strong>占用的内存给当前的<strong>block</strong>，腾出的大小由<strong>numBytesToFree</strong>决定(即不足的空间大小)。</li>
</ul>
<ol>
<li>调用<strong>MemoryStore</strong>的<strong>evictBlocksToFreeSpace</strong>方法，腾出<strong>numBytesToFree</strong>属性指定大小的空间。</li>
<li>当前<strong>StorageMemoryPool</strong>的空闲内存(<strong>memoryFree</strong>)是否充足。即<strong>numBytesToAcquire</strong> &lt;= <strong>memoryFree</strong></li>
<li>如果内存充足，则将<strong>numBytesToAcquire</strong>增加到<strong>_memoryUsed</strong>属性上，即逻辑上获得了用于存储<strong>block</strong>的内存空间。</li>
<li>返回<strong>enoughMemory</strong>布尔值，表示是否成功获得了<strong>block</strong>所需要的内存空间。 </li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">acquireMemory</span></span>(</span><br><span class="line">    blockId: <span class="type">BlockId</span>,</span><br><span class="line">    numBytesToAcquire: <span class="type">Long</span>,</span><br><span class="line">    numBytesToFree: <span class="type">Long</span>): <span class="type">Boolean</span> = lock.synchronized &#123;</span><br><span class="line">  assert(numBytesToAcquire &gt;= <span class="number">0</span>)</span><br><span class="line">  assert(numBytesToFree &gt;= <span class="number">0</span>)</span><br><span class="line">  assert(memoryUsed &lt;= poolSize)</span><br><span class="line">  <span class="keyword">if</span> (numBytesToFree &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    memoryStore.evictBlocksToFreeSpace(<span class="type">Some</span>(blockId), numBytesToFree, memoryMode)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">val</span> enoughMemory = numBytesToAcquire &lt;= memoryFree</span><br><span class="line">  <span class="keyword">if</span> (enoughMemory) &#123;</span><br><span class="line">    _memoryUsed += numBytesToAcquire</span><br><span class="line">  &#125;</span><br><span class="line">  enoughMemory</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="releaseMemory"><a href="#releaseMemory" class="headerlink" title="releaseMemory"></a>releaseMemory</h3><ul>
<li>释放指定大小的内存空间</li>
</ul>
<ol>
<li>如果需要释放的内存空间大小大于已经被使用的内存大小，可以理解为释放所有被占用的内存，将<strong>_memoryUsed</strong>直接清零。</li>
<li>否则，就在占用内存里减去释放的内存空间，即逻辑上释放了<strong>size</strong>大小的内存。</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">releaseMemory</span></span>(size: <span class="type">Long</span>): <span class="type">Unit</span> = lock.synchronized &#123;</span><br><span class="line">  <span class="keyword">if</span> (size &gt; _memoryUsed) &#123;</span><br><span class="line">    logWarning(<span class="string">s"Attempted to release <span class="subst">$size</span> bytes of storage "</span> +</span><br><span class="line">      <span class="string">s"memory when we only have <span class="subst">$&#123;_memoryUsed&#125;</span> bytes"</span>)</span><br><span class="line">    _memoryUsed = <span class="number">0</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    _memoryUsed -= size</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="freeSpaceToShrinkPool"><a href="#freeSpaceToShrinkPool" class="headerlink" title="freeSpaceToShrinkPool"></a>freeSpaceToShrinkPool</h3><ul>
<li>缩小指定大小的内存池空间。</li>
</ul>
<ol>
<li>对比<strong>spaceToFree</strong>和<strong>memoryFree</strong>的大小，如果<strong>spaceToFree</strong>小于<strong>memoryFree</strong>，直接返回<strong>spaceToFree</strong>即可。</li>
<li>如果<strong>spaceToFree</strong>大于<strong>memoryFree</strong>，说明需要腾出占用内存的部分<strong>block</strong>，以补齐<strong>spaceToFree</strong>的大小，返回腾出的空间<strong>spaceFreedByEviction</strong>与<strong>MemoryFree</strong>的大小之和。</li>
<li>由于驱逐了部分<strong>block</strong>的内存空间，所以<strong>_memoryUsed</strong>应该减少，但是这里没有做处理，原因是<strong>evictBlocksToFreeSpace</strong>的调动过程中，会调用<strong>blockEvictionHandler</strong>的<strong>dropFromMemory</strong>，而<strong>BlockManager</strong>的<strong>dropFromMemory</strong>方法会调用<strong>StorageMemoryPool</strong>的<strong>releaseMemory</strong>方法。</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">freeSpaceToShrinkPool</span></span>(spaceToFree: <span class="type">Long</span>): <span class="type">Long</span> = lock.synchronized &#123;</span><br><span class="line">  <span class="keyword">val</span> spaceFreedByReleasingUnusedMemory = math.min(spaceToFree, memoryFree) <span class="comment">//两者取最小值</span></span><br><span class="line">  <span class="keyword">val</span> remainingSpaceToFree = spaceToFree - spaceFreedByReleasingUnusedMemory</span><br><span class="line">  <span class="keyword">if</span> (remainingSpaceToFree &gt; <span class="number">0</span>) &#123;<span class="comment">// 大于0说明需要腾出空间</span></span><br><span class="line">    <span class="keyword">val</span> spaceFreedByEviction =</span><br><span class="line">      memoryStore.evictBlocksToFreeSpace(<span class="type">None</span>, remainingSpaceToFree, memoryMode)</span><br><span class="line">    spaceFreedByReleasingUnusedMemory + spaceFreedByEviction</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则直接返回spaceToFree的值即可</span></span><br><span class="line">    spaceFreedByReleasingUnusedMemory</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>StorageMemoryPool对应的是blockId与block所需的内存大小，ExecutionMemoryPool对应的是TaskAttemptId与任务尝试所消耗的内存大小。</em></strong></p>
<h2 id="ExecutionMemoryPool"><a href="#ExecutionMemoryPool" class="headerlink" title="ExecutionMemoryPool"></a>ExecutionMemoryPool</h2><ul>
<li>继承于MemoryPool，是执行内存池的具体实现，对执行内存的逻辑规划。</li>
</ul>
<table>
<thead>
<tr>
<th>属性/方法</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><strong>lock</strong></td>
<td>继承于MemoryPool的锁，保证操作内存池的线程安全。</td>
</tr>
<tr>
<td>_<strong>poolSize</strong></td>
<td>执行内存池的大小。</td>
</tr>
<tr>
<td><strong>memoryMode</strong></td>
<td>内存模式，ON_HEAP/OFF_HEAP两种。</td>
</tr>
<tr>
<td><strong>poolName</strong></td>
<td>内存池名称，根据memoryMode取名，on_heap execution或off_heap execution</td>
</tr>
<tr>
<td><strong>memoryForTask</strong></td>
<td>任务尝试的身份标识taskAttemptId与所消费内存大小之间的映射表。</td>
</tr>
<tr>
<td><strong>memoryUsed</strong></td>
<td>获取已使用的内存大小(bytes)，实际上是所有TaskAttemptId所消费的内存大小之和，即memoryForTask这个Map中所有value的和。</td>
</tr>
<tr>
<td><strong>getMemoryUsageForTask</strong></td>
<td>获取任务尝试使用的内存大小，即memoryForTask中taskAttemptId对应的value值。</td>
</tr>
</tbody></table>
<p><strong>以下为重点方法详解</strong></p>
<h3 id="acquireMemory-1"><a href="#acquireMemory-1" class="headerlink" title="acquireMemory"></a>acquireMemory</h3><ul>
<li>用于给<strong>taskAttemptId</strong>对应的任务尝试获取指定大小(<strong>numbytes</strong>)的内存。<br>申请内存的具体执行步骤如下:</li>
</ul>
<ol>
<li><p>如果<strong>memoryForTask</strong>中未包含当前<strong>taskAttemptId</strong>，则将当前<strong>taskAttemptId</strong>加入到<strong>memoryForTask</strong>中，并记录其消费的内存为0。唤醒其他等待获取<strong>ExecutionMemoryPool</strong>的线程。</p>
</li>
<li><p>一直循环以下操作:<br>(1) 获取当前激活的Task总数。</p>
<p>(2) 获取当前任务尝试所消费的内存大小。</p>
<p>(3) 调用<strong>maybeGrowPool</strong>方法，回收<strong>StorageMemoryPool</strong>从<strong>ExecutionMemoryPool</strong>里借用的内存。</p>
<p>(4) 调用<strong>computeMaxPoolSize</strong>方法，计算内存池的最大大小。</p>
<p>(5) 计算每个任务尝试可以使用的最大内存大小。(<strong>maxMemoryPerTask</strong>)</p>
<p>(6) 计算每个任务尝试可以使用的最小内存大小。(<strong>minMemoryPerTask</strong>)</p>
<p>(7) 计算当前任务尝试真正可以申请获取的内存大小。(<strong>toGrant</strong>)</p>
<p>(8) 如果<strong>toGrant</strong>小于任务尝试本来要申请的内存大小，并且当前任务尝试所消费的内存大小<strong>curMem</strong>与可以申请获取的内存大小<strong>toGrant</strong>之和小于<strong>minMemoryPerTask</strong>。会使得当前线程处于等待状态，这说明如果任务尝试要申请的内存得不到满足，甚至连每个任务需要的最小内存1/2N都无法满足，则需要等待其他线程的任务释放内存，当其他任务释放内存后，进入下一次<strong>loop</strong>，直到获取到满意的内存大小。</p>
<p>(9) 如果<strong>toGrant</strong>大于任务尝试需要申请的内存，说明真正可以申请的内存大小超出了期望获取的内存大小，或者<strong>curMem</strong>和<strong>toGrant</strong>之和大于等于<strong>minMemoryPerTask</strong>，说明当前任务尝试得到了最基本的内存保证(1/2N)。直接在<strong>memoryForTask</strong>中给该任务尝试对应的消费内存增加<strong>toGrant</strong>内存大小，并返回<strong>toGrant</strong>退出循环。</p>
</li>
</ol>
<p><strong>注意： maybeGrowPool是一个在MemoryManager的子类中定义的方法，用于计算存储内存池”占用”计算内存池的内存大小，返回存储内存池应该”回收”的内存大小。</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[memory] <span class="function"><span class="keyword">def</span> <span class="title">acquireMemory</span></span>(</span><br><span class="line">      numBytes: <span class="type">Long</span>,</span><br><span class="line">      taskAttemptId: <span class="type">Long</span>,</span><br><span class="line">      <span class="comment">// 在MemoryManager的子类中定义的方法，返回存储内存池应该归还的内存大小。</span></span><br><span class="line">      maybeGrowPool: <span class="type">Long</span> =&gt; <span class="type">Unit</span> = (additionalSpaceNeeded: <span class="type">Long</span>) =&gt; <span class="type">Unit</span>,</span><br><span class="line">      computeMaxPoolSize: () =&gt; <span class="type">Long</span> = () =&gt; poolSize): <span class="type">Long</span> = lock.synchronized &#123;</span><br><span class="line">    assert(numBytes &gt; <span class="number">0</span>, <span class="string">s"invalid number of bytes requested: <span class="subst">$numBytes</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!memoryForTask.contains(taskAttemptId)) &#123;</span><br><span class="line">      memoryForTask(taskAttemptId) = <span class="number">0</span>L</span><br><span class="line">      lock.notifyAll()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">val</span> numActiveTasks = memoryForTask.keys.size </span><br><span class="line">      <span class="keyword">val</span> curMem = memoryForTask(taskAttemptId) </span><br><span class="line"></span><br><span class="line">      maybeGrowPool(numBytes - memoryFree)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> maxPoolSize = computeMaxPoolSize()</span><br><span class="line">      <span class="keyword">val</span> maxMemoryPerTask = maxPoolSize / numActiveTasks</span><br><span class="line">      <span class="keyword">val</span> minMemoryPerTask = poolSize / (<span class="number">2</span> * numActiveTasks)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> maxToGrant = math.min(numBytes, math.max(<span class="number">0</span>, maxMemoryPerTask - curMem))</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> toGrant = math.min(maxToGrant, memoryFree)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (toGrant &lt; numBytes &amp;&amp; curMem + toGrant &lt; minMemoryPerTask) &#123;</span><br><span class="line">        logInfo(<span class="string">s"TID <span class="subst">$taskAttemptId</span> waiting for at least 1/2N of <span class="subst">$poolName</span> pool to be free"</span>)</span><br><span class="line">        lock.wait()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        memoryForTask(taskAttemptId) += toGrant</span><br><span class="line">        <span class="keyword">return</span> toGrant</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">0</span>L  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="releaseMemory-1"><a href="#releaseMemory-1" class="headerlink" title="releaseMemory"></a>releaseMemory</h3><ul>
<li>用于给<strong>taskAttemptId</strong>对应的任务尝试释放指定大小(<strong>numbytes</strong>)的内存。</li>
</ul>
<ol>
<li><p>获取<strong>taskAttemptId</strong>代表的任务尝试所消费的内存(<strong>curMem</strong>)。</p>
</li>
<li><p>如果<strong>curMem</strong> &lt; <strong>numBytes</strong>，即当前任务尝试消费的内存小于请求释放的内存，则真正需要释放的内存就是当前任务尝试消费的内存大小(<strong>memoryToFree=curMem</strong>)。否则，真正需要释放的内存就是请求释放的内存(<strong>memoryToFree=numBytes</strong>)。</p>
</li>
<li><p>如果<strong>memoryForTask</strong>里有当前任务尝试对应的<strong>taskAttemptId</strong>，将它对应消费的内存大小减去本次释放的内存大小(<strong>memoryToFree</strong>)。</p>
</li>
<li><p>如果减去<strong>memoryToFree</strong>大小的内存后，该<strong>taskAttemptId</strong>消费的内存小于等于0，则将其从<strong>memoryForTask</strong>中清除。</p>
</li>
<li><p>唤醒所有因为调用<strong>acquireMemory</strong>方法申请获得内存，却因为内存不足处于等待状态的线程。</p>
</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">releaseMemory</span></span>(numBytes: <span class="type">Long</span>, taskAttemptId: <span class="type">Long</span>): <span class="type">Unit</span> = lock.synchronized &#123;</span><br><span class="line">  <span class="keyword">val</span> curMem = memoryForTask.getOrElse(taskAttemptId, <span class="number">0</span>L)</span><br><span class="line">  <span class="keyword">var</span> memoryToFree = <span class="keyword">if</span> (curMem &lt; numBytes) &#123;</span><br><span class="line">    logWarning(</span><br><span class="line">      <span class="string">s"Internal error: release called on <span class="subst">$numBytes</span> bytes but task only has <span class="subst">$curMem</span> bytes "</span> +</span><br><span class="line">        <span class="string">s"of memory from the <span class="subst">$poolName</span> pool"</span>)</span><br><span class="line">    curMem</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    numBytes</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (memoryForTask.contains(taskAttemptId)) &#123;</span><br><span class="line">    memoryForTask(taskAttemptId) -= memoryToFree</span><br><span class="line">    <span class="keyword">if</span> (memoryForTask(taskAttemptId) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      memoryForTask.remove(taskAttemptId)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  lock.notifyAll()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="releaseAllMemoryForTask"><a href="#releaseAllMemoryForTask" class="headerlink" title="releaseAllMemoryForTask"></a>releaseAllMemoryForTask</h3><ul>
<li>用于释放<strong>taskAttemptId</strong>对应的任务尝试所消费的所有内存。</li>
</ul>
<ol>
<li>首先调用<strong>getMemoryUsageForTask</strong>获取该任务尝试消费的内存大小。</li>
<li>调用<strong>releaseMemory</strong>方法释放内存。</li>
<li>返回释放的内存大小。</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">releaseAllMemoryForTask</span></span>(taskAttemptId: <span class="type">Long</span>): <span class="type">Long</span> = lock.synchronized &#123;</span><br><span class="line">  <span class="keyword">val</span> numBytesToFree = getMemoryUsageForTask(taskAttemptId)</span><br><span class="line">  releaseMemory(numBytesToFree, taskAttemptId)</span><br><span class="line">  numBytesToFree</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重点小结"><a href="#重点小结" class="headerlink" title="重点小结"></a>重点小结</h2><ol>
<li><strong>StorageMemoryPool</strong>为<strong>blockId</strong>对应的<strong>block</strong>申请指定大小的内存，<strong>ExecutionMemoryPool</strong>为<strong>TaskAttemptId</strong>对应的任务尝试获取指定大小的内存。</li>
<li><strong>freeSpaceToShrinkPool</strong>决定了是否需要驱逐<strong>Block</strong>以释放内存，实际调用<strong>memoryStore</strong>的<strong>evictBlocksToFreeSpace</strong>，而<strong>evictBlocksToFreeSpace</strong>将调用<strong>blockEvictionHandler</strong>的<strong>dropFromMemory</strong>方法对内存进行释放，实际操作的是<strong>BlockManager</strong>的<strong>dropFromMemory</strong>方法，最终通过<strong>remove</strong>方法回到<strong>MemoryStore</strong>里的<strong>releaseMemory</strong>实现内存释放。</li>
<li><strong>ExecutionMemoryPool</strong>在内存不足时，会调用<strong>maybeGrowPool</strong>方法回收<strong>Storage</strong>占用的内存，如<strong>UnifiedMemoryManager</strong>子类实现的<strong>maybeGrowExecutionPool</strong>方法，内部调用<strong>freeSpaceToShrinkPool</strong>释放<strong>block</strong>占用的内存，并对存储以及计算内存池两者大小进行调整。</li>
<li><strong>ExecutionMemoryPool</strong>采用死循环的方式为<strong>TaskAttempt</strong>申请内存，内存至少为: 执行内存池大小* 1/(2*任务尝试个数)，否则将继续等待，直到其他<strong>TaskAttempt</strong>释放内存。</li>
</ol>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/08/09/Python-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/" rel="prev" title="[Python]多线程编程">
      <i class="fa fa-chevron-left"></i> [Python]多线程编程
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/05/16/Spark-Core-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-MemoryStore-3/" rel="next" title="Spark Core [源码解析] MemoryStore(3)">
      Spark Core [源码解析] MemoryStore(3) <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SinGle</span>
</div>
  <div class="powered-by">Powered by <a href="https://single-cabin.com/" class="theme-link" rel="noopener" target="_blank">SinGle-Cabin</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  















  

  

</body>
</html>
